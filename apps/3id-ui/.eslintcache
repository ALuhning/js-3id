[{"/Users/sterahi/Documents/3id-connect/apps/3id-ui/src/index.tsx":"1","/Users/sterahi/Documents/3id-connect/apps/3id-ui/src/reportWebVitals.ts":"2","/Users/sterahi/Documents/3id-connect/apps/3id-ui/src/Components/App/App.tsx":"3","/Users/sterahi/Documents/3id-connect/apps/3id-ui/src/services/connectService.ts":"4","/Users/sterahi/Documents/3id-connect/apps/3id-ui/src/services/iframeService.ts":"5"},{"size":4315,"mtime":1632162434227,"results":"6","hashOfConfig":"7"},{"size":425,"mtime":1631726800436,"results":"8","hashOfConfig":"7"},{"size":3083,"mtime":1632162338978,"results":"9","hashOfConfig":"7"},{"size":10551,"mtime":1632158727364,"results":"10","hashOfConfig":"7"},{"size":2324,"mtime":1632160963811,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"1adntqf",{"filePath":"14","messages":"15","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"16","usedDeprecatedRules":"17"},{"filePath":"18","messages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"20","messages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22","usedDeprecatedRules":"17"},{"filePath":"23","messages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"17"},"/Users/sterahi/Documents/3id-connect/apps/3id-ui/src/index.tsx",["26"],"/Users/sterahi/Documents/3id-connect/apps/3id-ui/src/reportWebVitals.ts",["27"],"import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n",["28","29"],"/Users/sterahi/Documents/3id-connect/apps/3id-ui/src/Components/App/App.tsx",["30","31","32"],"/Users/sterahi/Documents/3id-connect/apps/3id-ui/src/services/connectService.ts",["33","34","35","36","37","38","39","40","41","42","43","44","45"],"/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access */\n\nimport { ThreeIDError, assert } from '@3id/common'\nimport { DisplayManageClientRPC } from '@3id/connect-display'\nimport { Manager, legacyDIDLinkExist, willMigrationFail, Migrate3IDV0 } from '@3id/manager'\nimport { AuthProviderClient } from '@3id/window-auth-provider'\nimport CeramicClient from '@ceramicnetwork/http-client'\nimport { IDX } from '@ceramicstudio/idx'\nimport ThreeIdProvider from '3id-did-provider'\nimport type { DIDMethodName, DIDProvider, DIDProviderMethods, DIDRequest, DIDResponse } from 'dids'\nimport type { RPCRequest, RPCResponse, RPCResultResponse } from 'rpc-utils'\nimport Url from 'url-parse'\nimport { UIProvider, ThreeIDManagerUI, AuthParams } from '@3id/ui-provider/src'\n\nimport { IframeService } from './iframeService'\n/**\n * TODO: Export this block to @3id/common\n */\nimport { RPCError } from 'rpc-utils'\nimport type { RPCErrorObject } from 'rpc-utils'\n\n// TODO didprovider, auth failed codes?\nconst rpcError = (id: string | number): RPCErrorObject & { id: string | number } => {\n  const rpcError = new RPCError(-32401, `3id-connect: Request not authorized`)\n  return Object.assign(rpcError.toObject(), { id })\n}\n/**\n * End export block\n */\n\nconst CERAMIC_API = process.env.CERAMIC_API || 'https://ceramic-private.3boxlabs.com'\nconst DID_MIGRATION = process.env.MIGRATION ? process.env.MIGRATION === 'true' : true // default true\n\n// Any other supported method?\ntype Methods = DIDProviderMethods\ntype UserRequestCancel = (callback?: () => void) => void\n\n/**\n *  ConnectService runs a 3ID DID provider instance and rpc server with\n *  bindings to receive and relay rpc messages to identity wallet\n */\nexport class ConnectService extends IframeService<DIDProviderMethods> {\n  uiManager: ThreeIDManagerUI | undefined\n  cancel: UserRequestCancel | undefined\n\n  ceramic: CeramicClient | undefined\n  threeId: ThreeIdProvider | undefined\n  idx: IDX | undefined\n  provider: DIDProvider | undefined\n\n  manageApp: DisplayManageClientRPC | undefined\n\n  /**\n   *  Start connect service. Once returns ready to receive rpc requests\n   *\n   * @param     {Function}    uiProvider           A uiProvider instance\n   * @param     {Function}    cancel               Function to cancel request, consumes callback, which is called when request is cancelled (cb) => {...}\n   */\n  // @ts-ignore method override\n  start(uiProvider: UIProvider, cancel: UserRequestCancel): void {\n    this.cancel = cancel\n    this.uiManager = new ThreeIDManagerUI(uiProvider)\n    this.ceramic = new CeramicClient(CERAMIC_API, { syncInterval: 30 * 60 * 1000 })\n    super.start(this.requestHandler.bind(this))\n    this.manageApp = new DisplayManageClientRPC()\n  }\n\n  async init(\n    accountId: string,\n    authReq: DIDRequest<'did_authenticate'>,\n    domain?: string | null\n  ): Promise<void> {\n    assert.isDefined(this.uiManager, 'UI Manager must be defined')\n    assert.isDefined(this.manageApp, 'manageApp must be defined')\n\n    const authProviderRelay = new AuthProviderClient(window.parent)\n    const manage = new Manager(authProviderRelay, { ceramic: this.ceramic })\n\n    //TODO if exist in state, return before even looking up links\n    const existLocally = await manage.cache.getLinkedDid(accountId)\n    const existNetwork = await manage.linkInNetwork(accountId)\n\n    const newAccount = !existNetwork && !existLocally\n\n    // Await during user prompt\n    const legacyDidPromise = legacyDIDLinkExist(accountId)\n\n    // Before to give context, and no 3id-did-provider permission exist\n    if (!existLocally && !newAccount) {\n      await this.userPermissionRequest(authReq, domain)\n    }\n\n    //TODO if not exist locally and not in network, then skip first modal aboev, and merge below with create\n\n    let legacyDid = await legacyDidPromise\n    let muportDid\n\n    if (legacyDid) {\n      await this.userPermissionRequest(authReq, domain)\n    }\n\n    // For legacy muport dids, do not migrate, create new did, but still try to migrate profile data\n    if (legacyDid && legacyDid.includes('muport')) {\n      muportDid = legacyDid\n      legacyDid = null\n    }\n\n    // For known failure cases, skip migrations prompts\n    let willFail\n    if (legacyDid) {\n      willFail = await willMigrationFail(accountId, legacyDid)\n      if (willFail) legacyDid = null\n    }\n\n    // If new account (and not migration), ask user to link or create\n    if (!(legacyDid || muportDid || willFail) && newAccount) {\n      const createNew = (await this.uiManager.promptAccount()).createNew\n      if (!createNew) {\n        await this.manageApp.display(accountId)\n      }\n    }\n\n    if (DID_MIGRATION && newAccount) {\n      if (willFail || muportDid) {\n        await this.uiManager.promptMigrationSkip()\n      }\n      if (legacyDid) {\n        await this.uiManager.promptMigration({ legacyDid })\n      }\n    }\n\n    let did: string\n    try {\n      // Skip migration if muport or known failure\n      // @ts-ignore TODO: resolve why legacyDid is resolving to string | undefined and not string | null\n      did = await manage.createAccount({ legacyDid, skipMigration: Boolean(muportDid || willFail) })\n    } catch (e: any) {\n      if (legacyDid) {\n        await this.uiManager.promptMigrationFail()\n        // If migration fails, continue with new did instead\n        did = await manage.createAccount({ skipMigration: true })\n      } else {\n        console.error(e)\n        throw new Error(e)\n      }\n    }\n\n    this.threeId = manage.threeIdProviders[did]\n    // @ts-ignore resolve why domain is possibly string | null | undefined and not string | undefined\n    this.provider = this.threeId.getDidProvider(domain) as DIDProvider\n\n    if (muportDid) {\n      //Try to migrate profile data still for muport did\n      try {\n        const migration = new Migrate3IDV0(this.provider, manage.idx)\n        await migration.migrate3BoxProfile(muportDid)\n      } catch (e) {\n        // If not available, continue\n      }\n    }\n\n    // After since 3id-did-provider permissions may exist\n    if (existLocally) {\n      await this.userPermissionRequest(authReq, domain, did)\n    }\n  }\n\n  async userPermissionRequest(\n    authReq: DIDRequest,\n    domain?: string | null,\n    did?: string\n  ): Promise<void> {\n    assert.isDefined(this.uiManager, 'User request handler must be defined')\n    this.cancel!(() => {\n      throw new Error('3id-connect: Request not authorized')\n    })\n    const userReq = this._createUserRequest(authReq, domain, did)\n    if (!userReq) return\n    const userPermission = userReq ? await this.uiManager.promptAuthenticate(userReq) : null\n    if (!userPermission) throw new Error('3id-connect: Request not authorized')\n  }\n\n  async requestHandler(message: RPCRequest<Methods, keyof Methods>): Promise<string> {\n    const domain = new Url(document.referrer).host\n    console.log(message)\n\n    const responsePromise = new Promise((resolve, reject) => {\n      // Register request cancel calback\n      this.cancel!(() => resolve(rpcError(message.id!)))\n      if (message.method.startsWith('did')) {\n        this.requestHandlerDid(message, domain).then(resolve, reject)\n      } else {\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        const msg = `Unsupported method ${message.method}: only did_ and 3id_ methods are supported`\n        reject(new ThreeIDError(4, msg))\n      }\n    })\n\n    return JSON.stringify(await responsePromise)\n  }\n\n  /**\n   *  Consumes DID RPC request message and relays to IDW didprovider instance. Also handles\n   *  logic to retry requests and cancel requests.\n   *\n   * @param     {Object}      message    DID RPC request message\n   * @return    {String}                 response message string\n   */\n\n  async requestHandlerDid<K extends DIDMethodName>(\n    message: DIDRequest<K>,\n    domain?: string\n  ): Promise<\n    K extends 'did_authenticate'\n      ? RPCResultResponse<DIDProviderMethods['did_authenticate']['result']> | RPCErrorObject | void\n      : DIDResponse<K> | null\n  > {\n    return message.method === 'did_authenticate'\n      ? ((await this._didAuthReq(message as DIDRequest<'did_authenticate'>, domain)) as any)\n      : await this._relayDidReq(message, domain)\n  }\n\n  async _didAuthReq(\n    message: RPCRequest<DIDProviderMethods, 'did_authenticate'>,\n    domain?: string | null\n  ): Promise<\n    | RPCResultResponse<DIDProviderMethods['did_authenticate']['result']>\n    | RPCErrorObject\n    | null\n    | void\n  > {\n    assert.isDefined(message.params, 'Message parameters must be defined')\n\n    try {\n      const accountId = (message.params as unknown as { accountId: string }).accountId\n\n      await this.init(accountId, message, domain)\n\n      assert.isDefined(this.provider, 'DID provider must be defined')\n      //@ts-ignore TODO figure out why this.provider.send is only expecting one param\n      const res = await this.provider.send(message, domain)\n      await this.hideIframe()\n      return res as RPCResultResponse<DIDProviderMethods['did_authenticate']['result']>\n    } catch (e) {\n      if ((e as Error).toString().includes('authorized')) {\n        await this.hideIframe()\n        return rpcError(message.id!)\n      }\n      if (this.uiManager) {\n        //@ts-ignore - Identify if type needs to be updated or ignored\n        // based on RPCError type expecting data to be undefined.\n        this.uiManager.noftifyError({ code: 0, data: e, message: 'Error: Unable to connect' })\n      }\n    }\n  }\n\n  async _relayDidReq<K extends keyof DIDProviderMethods>(\n    req: RPCRequest<DIDProviderMethods, K>,\n    domain?: string | null\n  ): Promise<RPCResponse<DIDProviderMethods, K> | null> {\n    assert.isDefined(this.provider, 'DID provider must be defined')\n    //@ts-ignore TODO figure out why this.provider.send is only expecting one param\n    return await this.provider.send(req, domain)\n  }\n\n  _createUserRequest<K extends keyof DIDProviderMethods>(\n    req: RPCRequest<DIDProviderMethods, K>,\n    origin?: string | null,\n    did?: string\n  ): AuthParams | null {\n    assert.isDefined(req.params, 'Request parameters must be provided')\n    const params = req.params as DIDProviderMethods[K]['params'] & { paths?: Array<string> }\n\n    if (this.threeId) {\n      const has = params.paths ? this.threeId.permissions.has(origin, params.paths) : true\n      if (has) return null\n    }\n    return {\n      type: 'authenticate',\n      // @ts-ignore - figure out why origin complains.\n      origin,\n      paths: params.paths || [],\n      did: did || '',\n    }\n  }\n}\n","/Users/sterahi/Documents/3id-connect/apps/3id-ui/src/services/iframeService.ts",["46"],"import { DisplayConnectClientRPC } from '@3id/connect-display'\n//@ts-ignore - todo: create type for this\nimport { expose } from 'postmsg-rpc'\nimport type { RPCMethods, RPCRequest } from 'rpc-utils'\n\n// const mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i\n// const checkIsMobile = () => mobileRegex.test(navigator.userAgent)\n\n/**\n *  Iframe services binds functions to make calls to parent window for controlling iframe visibility\n *  and authProvider calls. It also runs rpc server to receive and realay request to another service.\n */\n\n//  TODO can just merge this back with connect service, this will just be init all rpc clients/servers needed\nexport class IframeService<Methods extends RPCMethods> {\n  display: (isMobile?: boolean, height?: string, width?: string) => Promise<void>\n  // displayTest = (isMobile?: boolean, height?: string, width?: string):Promise<void> => {\n\n  // }\n  hide: () => Promise<void>\n  iframeDisplay: DisplayConnectClientRPC\n\n  /**\n   * Create IframeService\n   */\n  constructor() {\n    this.iframeDisplay = new DisplayConnectClientRPC(window.parent)\n    this.display = this.iframeDisplay.display.bind(this.iframeDisplay)\n    this.hide = this.iframeDisplay.hide.bind(this.iframeDisplay)\n  }\n\n  /**\n   *  Start service, binds handler to start receiving incoming requests\n   *\n   * @param     {Function}    requestHandler    a function that will consume all rpc request from parent window (specifically didProvider calls)\n   */\n  // TODO replace this as well for did provider\n  start(requestHandler: (message: RPCRequest<Methods, keyof Methods>) => Promise<string>): void {\n    expose('send', requestHandler, { postMessage: window.parent.postMessage.bind(window.parent) })\n  }\n\n  /**\n   *  Tells parent window to display iframe\n   */\n  // async displayIframe(res: boolean): Promise<boolean> {\n  //   console.log('display iframe', res)\n  //   await this.display(false, '100%', '100%') //checkIsMobile()\n  //   return res\n  // }\n  async displayIframe(): Promise<boolean> {\n    await this.display(false, '100%', '100%') //checkIsMobile()\n    return true\n  }\n\n  /**\n   *  Tells parent window to hide iframe\n   */\n  async hideIframe(): Promise<void> {\n    const root = document.getElementById('root')\n    if (root) root.innerHTML = ``\n    return await this.hide()\n  }\n}\n",{"ruleId":"47","severity":1,"message":"48","line":7,"column":22,"nodeType":"49","messageId":"50","endLine":7,"endColumn":40},{"ruleId":"47","severity":1,"message":"51","line":1,"column":10,"nodeType":"49","messageId":"50","endLine":1,"endColumn":23},{"ruleId":"52","replacedBy":"53"},{"ruleId":"54","replacedBy":"55"},{"ruleId":"47","severity":1,"message":"56","line":4,"column":10,"nodeType":"49","messageId":"50","endLine":4,"endColumn":24},{"ruleId":"47","severity":1,"message":"57","line":6,"column":10,"nodeType":"49","messageId":"50","endLine":6,"endColumn":20},{"ruleId":"47","severity":1,"message":"48","line":7,"column":15,"nodeType":"49","messageId":"50","endLine":7,"endColumn":33},{"ruleId":"47","severity":1,"message":"58","line":8,"column":10,"nodeType":"49","messageId":"50","endLine":8,"endColumn":13},{"ruleId":"47","severity":1,"message":"59","line":9,"column":8,"nodeType":"49","messageId":"50","endLine":9,"endColumn":23},{"ruleId":"47","severity":1,"message":"60","line":10,"column":15,"nodeType":"49","messageId":"50","endLine":10,"endColumn":28},{"ruleId":"47","severity":1,"message":"61","line":10,"column":30,"nodeType":"49","messageId":"50","endLine":10,"endColumn":41},{"ruleId":"47","severity":1,"message":"62","line":10,"column":43,"nodeType":"49","messageId":"50","endLine":10,"endColumn":61},{"ruleId":"47","severity":1,"message":"63","line":10,"column":63,"nodeType":"49","messageId":"50","endLine":10,"endColumn":73},{"ruleId":"47","severity":1,"message":"64","line":10,"column":75,"nodeType":"49","messageId":"50","endLine":10,"endColumn":86},{"ruleId":"47","severity":1,"message":"65","line":11,"column":15,"nodeType":"49","messageId":"50","endLine":11,"endColumn":25},{"ruleId":"47","severity":1,"message":"66","line":11,"column":27,"nodeType":"49","messageId":"50","endLine":11,"endColumn":38},{"ruleId":"47","severity":1,"message":"67","line":11,"column":40,"nodeType":"49","messageId":"50","endLine":11,"endColumn":57},{"ruleId":"47","severity":1,"message":"57","line":13,"column":10,"nodeType":"49","messageId":"50","endLine":13,"endColumn":20},{"ruleId":"47","severity":1,"message":"68","line":13,"column":40,"nodeType":"49","messageId":"50","endLine":13,"endColumn":50},{"ruleId":"47","severity":1,"message":"69","line":20,"column":15,"nodeType":"49","messageId":"50","endLine":20,"endColumn":29},{"ruleId":"47","severity":1,"message":"70","line":4,"column":15,"nodeType":"49","messageId":"50","endLine":4,"endColumn":25},"@typescript-eslint/no-unused-vars","'UIProviderHandlers' is defined but never used.","Identifier","unusedVar","'ReportHandler' is defined but never used.","no-native-reassign",["71"],"no-negated-in-lhs",["72"],"'ConnectService' is defined but never used.","'UIProvider' is defined but never used.","'IDX' is defined but never used.","'ThreeIdProvider' is defined but never used.","'DIDMethodName' is defined but never used.","'DIDProvider' is defined but never used.","'DIDProviderMethods' is defined but never used.","'DIDRequest' is defined but never used.","'DIDResponse' is defined but never used.","'RPCRequest' is defined but never used.","'RPCResponse' is defined but never used.","'RPCResultResponse' is defined but never used.","'AuthParams' is defined but never used.","'RPCErrorObject' is defined but never used.","'RPCMethods' is defined but never used.","no-global-assign","no-unsafe-negation"]